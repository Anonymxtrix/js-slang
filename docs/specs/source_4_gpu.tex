\input source_header.tex

\begin{document}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\docheader{2021}{Source}{\S 4 GPU}{Martin Henz}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input source_intro.tex

\section*{Changes}

This document oultines the syntax and functionality of Source \S GPU. 
Source \S GPU is built on Source \S 4 GPU. The specifications for this language are listed here.

\input source_bnf.tex

\input source_gpu_bnf.tex

\newpage

\section*{Restrictions}

Even if the BNF syntax is met, GPU acceleration can only take place if all the restrictions below are satisfied. If all criteria are met, the \textit{gpu\_statement} loops are embarrassingly parallel.

\subsection*{Special For Loops}

In the BNF, we have special loops that take on this form:

\begin{alignat*}{9}
&& \textbf{\texttt{for}}\ \textbf{\texttt{(}} 
                          \ \textit{gpu\_for\_let} \textbf{\texttt{;}} \\
&& \ \ \textit{gpu\_condition} \textbf{\texttt{;}} \\
&& \textit{gpu\_for\_assignment} \ )
\end{alignat*}

These are the loops that will be taken into consideration for parallelization. However, on top of the BNF syntax, the below requirement must also be statisfied:

\begin{itemize}
    \item{the names used in each for loop has to be different across the loops (no repeating identifiers among the for loops)}
    \item{the names have to be the same within the loop}
\end{itemize}

\subsection*{GPU Function}

A \textit{gpu\_function} has to be a \textit{math\_\texttt{*}} function

\subsection*{Core Statement}

Within \textit{core\_statement}, there are some constraints:

\begin{itemize}
    \item{no assignment to any global variables (all assignments can only be done to variables defined in the \textit{gpu\_block}})
\end{itemize}

\subsection*{GPU Result Statement}

The GPU Result statement is the statement that stores a value calculated in core statements into a result array. It access an array at a certain coordinate e.g. ${array[{i_1}][{i_2}][{i_3}]}$. This result array has to be defined outside the \textit{gpu\_block}.\\

The sequence of coordinates which we access in the result array ${{i_1}, {i_2}, {i_3} ... i_{k}}$ must be a prefix of the special for loop counters ${[c_1,c_2 ... c_n]}$. If you have ${n}$ special for loops, the array expression can take on ${k}$ coordinates where ${0 < k \leq n}$. The order matters as well, it has to follow the same order as the special for loops: you cannot have ${name[c_2][c_1]}$.

\newpage

\section*{Examples}

Below are some examples of valid and invalid source gpu programs:\\

\textbf{Valid} - Using first loop counter. (meaning the loop will be run across N threads; the first loop is parallelized away):
\begin{verbatim}
for (let i = 0; i < N; i = i + 1) {
    for (let k = 0; k < M; k = k + 1) {
        res[i] = arr[k % 2] + 1;
    }
}
\end{verbatim}

\textbf{Invalid} - Counter used is not a prefix of for loop counters:
\begin{verbatim}
for (let i = 0; i < N; i = i + 1) {
    for (let k = 0; k < M; k = k + 1) {
        res[k] = arr[i % 2] + 1;
    }
}
\end{verbatim}

\textbf{Valid} - Using first three loop counters:
\begin{verbatim}
for (let i = 0; i < N; i = i + 1) {
    for (let j = 0; j < M; j = j + 1) {
        for (let k = 0; k < C; k = k + 1) {
            let x = math_pow(2, 10);
            let y = x * (1000);
            arr[i][j][k] = (x + y * 2);
        }
    }
}
\end{verbatim}

\textbf{Invalid} - Indices are in wrong order (must respect for loop counter orders):
\begin{verbatim}
for (let i = 0; i < N; i = i + 1) {
    for (let j = 0; j < M; j = j + 1) {
        for (let k = 0; k < C; k = k + 1) {
            let x = math_pow(2, 10);
            let y = x * (1000);
            res[k][j][i] = (x + y * 2);
        }
    }
}
\end{verbatim}

\textbf{Invalid} - Using an index that is not part of a special for loop (see above):
\begin{verbatim}
for (let i = 0; i < N; i = i + 1) {
    for (let j = 0; j < M; j = j + 1) {
        for (let k = 1; k < C; k = k + 2) {
            res[k] = arr1[i] + arr2[j];
        }
    }
}
\end{verbatim}

\end{document}
